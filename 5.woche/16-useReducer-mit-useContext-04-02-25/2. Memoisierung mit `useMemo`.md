# **ğŸ“Œ `useMemo` ile Bellek Optimizasyonu (Memoization)**
  
### **1ï¸âƒ£ `useMemo` Nedir?**
`useMemo`, **Reactâ€™te performansÄ± artÄ±rmak iÃ§in kullanÄ±lan bir Hookâ€™tur**.  
Bir fonksiyonun **her render'da tekrar Ã§alÄ±ÅŸmasÄ±nÄ± Ã¶nleyerek**, **Ã¶nceden hesaplanmÄ±ÅŸ sonucu (memoization) kullanÄ±r**.

âœ… **AÄŸÄ±r (CPU-intensive) iÅŸlemleri gereksiz yere tekrar Ã§alÄ±ÅŸtÄ±rmaz.**  
âœ… **Gereksiz hesaplamalarÄ±n Ã¶nÃ¼ne geÃ§erek performansÄ± artÄ±rÄ±r.**  
âœ… **Ã–zellikle bÃ¼yÃ¼k listelerde `filter`, `map`, `reduce` gibi iÅŸlemler yaparken kullanÄ±lÄ±r.**  

---

### **2ï¸âƒ£ `useMemo` Neden KullanÄ±lÄ±r?**
ğŸ“Œ **Normalde bir bileÅŸen her render olduÄŸunda, iÃ§indeki tÃ¼m kodlar tekrar Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.**  

Ã–rneÄŸin:
```js
const result = slowFunction();
```
Bu fonksiyon her renderâ€™da **tekrar Ã§alÄ±ÅŸÄ±r**.  
EÄŸer Ã§ok aÄŸÄ±r bir hesaplama yapÄ±yorsa **gereksiz performans kaybÄ±** yaÅŸanÄ±r.

**Ã‡Ã¶zÃ¼m:**  
EÄŸer **hesaplama sonucu deÄŸiÅŸmiyorsa**, bunu `useMemo` ile **Ã¶nceden hesaplayÄ±p saklayabiliriz**:
```js
const result = useMemo(() => slowFunction(), []);
```
ğŸ“Œ **BÃ¶ylece fonksiyon sadece bir kez Ã§alÄ±ÅŸÄ±r ve sonucu saklanÄ±r**.  
**BaÄŸÄ±mlÄ±lÄ±klar (`[]`) deÄŸiÅŸmedikÃ§e fonksiyon tekrar Ã§alÄ±ÅŸmaz**.

---

## **ğŸ“Œ `useMemo` KullanÄ±mÄ±**
KullanÄ±mÄ± ÅŸu ÅŸekildedir:

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

- **`useMemo`**, **ilk parametre olarak bir hesaplama fonksiyonu alÄ±r**.
- **Ä°kinci parametre olarak baÄŸÄ±mlÄ±lÄ±klar (`[a, b]`) verilir.**
- EÄŸer **`a` veya `b` deÄŸiÅŸmezse, hesaplama tekrar Ã§alÄ±ÅŸmaz** ve Ã¶nceki sonuÃ§ saklanÄ±r.

---

## **ğŸ“Œ Ã–rnek 1: AÄŸÄ±r HesaplamalarÄ± Optimize Etme**
AÅŸaÄŸÄ±daki Ã¶rnekte, **bir sayÄ±yÄ± artÄ±rÄ±rken aÄŸÄ±r bir fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±yoruz**.

### **ğŸ›‘ `useMemo` Olmadan Kod (KÃ¶tÃ¼ Performans)**  
```js
import React, { useState } from "react";

function slowFunction(num) {
  console.log("Slow function Ã§alÄ±ÅŸÄ±yor...");
  for (let i = 0; i < 1000000000; i++) {} // AÄŸÄ±r iÅŸlem simÃ¼lasyonu
  return num * 2;
}

function Counter() {
  const [count, setCount] = useState(0);
  const [number, setNumber] = useState(5);

  const doubled = slowFunction(number); // HER render'da Ã§alÄ±ÅŸÄ±yor ğŸ˜µ

  return (
    <div>
      <h2>Counter: {count}</h2>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <h2>Number: {number}</h2>
      <h2>Doubled: {doubled}</h2>
      <button onClick={() => setNumber(number + 1)}>Increase Number</button>
    </div>
  );
}

export default Counter;
```

ğŸ“Œ **Problem ne?**
- **SayacÄ± (`count`) artÄ±rdÄ±ÄŸÄ±mÄ±zda bile `slowFunction` Ã§alÄ±ÅŸÄ±yor!**
- `number` deÄŸiÅŸmediÄŸi halde **gereksiz hesaplama yapÄ±lÄ±yor**.

### **âœ… `useMemo` ile Optimize EdilmiÅŸ Kod**
```js
import React, { useState, useMemo } from "react";

function slowFunction(num) {
  console.log("Slow function Ã§alÄ±ÅŸÄ±yor...");
  for (let i = 0; i < 1000000000; i++) {} // AÄŸÄ±r iÅŸlem simÃ¼lasyonu
  return num * 2;
}

function Counter() {
  const [count, setCount] = useState(0);
  const [number, setNumber] = useState(5);

  const doubled = useMemo(() => slowFunction(number), [number]); // SADECE `number` deÄŸiÅŸince Ã§alÄ±ÅŸacak âœ…

  return (
    <div>
      <h2>Counter: {count}</h2>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <h2>Number: {number}</h2>
      <h2>Doubled: {doubled}</h2>
      <button onClick={() => setNumber(number + 1)}>Increase Number</button>
    </div>
  );
}

export default Counter;
```
âœ… **ArtÄ±k sadece `number` deÄŸiÅŸince `slowFunction` Ã§alÄ±ÅŸÄ±yor!**  
âœ… **`count` deÄŸiÅŸtiÄŸinde gereksiz hesaplama yapÄ±lmÄ±yor!**  

---

## **ğŸ“Œ Ã–rnek 2: BÃ¼yÃ¼k Listeyi Filtreleme**
Bir **bÃ¼yÃ¼k listeyi `useMemo` ile optimize edelim**.

### **ğŸ›‘ `useMemo` Olmadan (KÃ¶tÃ¼ Performans)**
```js
import React, { useState } from "react";

const users = Array.from({ length: 10000 }, (_, i) => ({
  id: i + 1,
  name: `User ${i + 1}`,
}));

function UserList() {
  const [search, setSearch] = useState("");

  const filteredUsers = users.filter((user) =>
    user.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    <div>
      <input
        type="text"
        placeholder="Search user..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <ul>
        {filteredUsers.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default UserList;
```
ğŸ“Œ **Problem ne?**  
- **KullanÄ±cÄ± her tuÅŸa bastÄ±ÄŸÄ±nda `users.filter()` tekrar Ã§alÄ±ÅŸÄ±yor!**
- **BÃ¼yÃ¼k listelerde performans kaybÄ±na neden olabilir.**

---

### **âœ… `useMemo` ile Optimize EdilmiÅŸ Hali**
```js
import React, { useState, useMemo } from "react";

const users = Array.from({ length: 10000 }, (_, i) => ({
  id: i + 1,
  name: `User ${i + 1}`,
}));

function UserList() {
  const [search, setSearch] = useState("");

  const filteredUsers = useMemo(() => {
    console.log("Filtreleme yapÄ±lÄ±yor...");
    return users.filter((user) =>
      user.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [search]); // SADECE `search` deÄŸiÅŸince Ã§alÄ±ÅŸÄ±r âœ…

  return (
    <div>
      <input
        type="text"
        placeholder="Search user..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <ul>
        {filteredUsers.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default UserList;
```
âœ… **ArtÄ±k `users.filter()` her renderâ€™da Ã§alÄ±ÅŸmÄ±yor!**  
âœ… **Sadece `search` deÄŸiÅŸtiÄŸinde filtreleme yapÄ±lÄ±yor!**  

---

## **ğŸ“Œ `useMemo` vs `useCallback`**
| **Ã–zellik**   | **useMemo** | **useCallback** |
|--------------|------------|---------------|
| **AmaÃ§** | AÄŸÄ±r hesaplamalarÄ± optimize etmek | FonksiyonlarÄ± optimize etmek |
| **Ne dÃ¶ndÃ¼rÃ¼r?** | DeÄŸer (`number`, `array`, `object`) | Fonksiyon (`function`) |
| **Ne zaman kullanÄ±lÄ±r?** | BÃ¼yÃ¼k listelerde filtreleme, hesaplamalar | Component propâ€™larÄ±nÄ± optimize etmek |

ğŸ“Œ **Ã–zet:**  
- **`useMemo`** â†’ **Hesaplama yapÄ±yorsan kullan.**  
- **`useCallback`** â†’ **Bir fonksiyonun gereksiz render edilmesini Ã¶nlemek iÃ§in kullan.**  

---

## **ğŸ¯ SonuÃ§**
âœ… **`useMemo`, aÄŸÄ±r hesaplamalarÄ± Ã¶nceden hesaplayÄ±p bellekte saklamak iÃ§in kullanÄ±lÄ±r.**  
âœ… **PerformansÄ± artÄ±rarak gereksiz tekrar hesaplamalarÄ± Ã¶nler.**  
âœ… **BÃ¼yÃ¼k listelerde `filter()`, `map()`, `reduce()` gibi iÅŸlemleri optimize etmek iÃ§in idealdir.**  
âœ… **Sadece baÄŸÄ±mlÄ±lÄ±klarÄ± deÄŸiÅŸtiÄŸinde hesaplama yapÄ±lÄ±r, bÃ¶ylece gereksiz renderâ€™lar Ã¶nlenir.**  

Bunu anladÄ±n mÄ±, yoksa daha fazla Ã¶rnek vererek geniÅŸleteyim mi? ğŸ˜ŠğŸš€